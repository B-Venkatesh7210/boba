From 09b9ba41097ba13b4c195b6f1ed2cd21a648a409 Mon Sep 17 00:00:00 2001
From: cby3149 <cby3149@gmail.com>
Date: Fri, 10 May 2024 10:37:23 -0700
Subject: [PATCH] BNB L2

---
 .../contracts-bedrock/scripts/Deploy.s.sol    |  6 +-
 .../src/L1/L1StandardBridge.sol               | 19 +++-
 .../src/L1/OptimismPortal.sol                 | 93 ++++++++++++++++++-
 .../src/L2/L2StandardBridge.sol               |  4 +-
 .../src/deployment/SystemDictator.sol         |  7 +-
 .../src/libraries/Predeploys.sol              |  3 +
 .../src/universal/CrossDomainMessenger.sol    |  2 +
 .../src/universal/StandardBridge.sol          | 76 +++++++++++----
 .../test/vendor/Initializable.t.sol           |  9 +-
 9 files changed, 190 insertions(+), 29 deletions(-)

diff --git a/packages/contracts-bedrock/scripts/Deploy.s.sol b/packages/contracts-bedrock/scripts/Deploy.s.sol
index d0acd4940..170a65256 100644
--- a/packages/contracts-bedrock/scripts/Deploy.s.sol
+++ b/packages/contracts-bedrock/scripts/Deploy.s.sol
@@ -878,7 +878,11 @@ contract Deploy is Deployer {
             _implementation: l1StandardBridge,
             _innerCallData: abi.encodeCall(
                 L1StandardBridge.initialize,
-                (L1CrossDomainMessenger(l1CrossDomainMessengerProxy), SuperchainConfig(superchainConfigProxy))
+                (
+                    L1CrossDomainMessenger(l1CrossDomainMessengerProxy),
+                    SuperchainConfig(superchainConfigProxy),
+                    BOBA(address(0))
+                )
                 )
         });
 
diff --git a/packages/contracts-bedrock/src/L1/L1StandardBridge.sol b/packages/contracts-bedrock/src/L1/L1StandardBridge.sol
index 6958dc2e7..26831b774 100644
--- a/packages/contracts-bedrock/src/L1/L1StandardBridge.sol
+++ b/packages/contracts-bedrock/src/L1/L1StandardBridge.sol
@@ -7,6 +7,7 @@ import { ISemver } from "src/universal/ISemver.sol";
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
 import { SuperchainConfig } from "src/L1/SuperchainConfig.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
 /// @custom:proxied
 /// @title L1StandardBridge
@@ -78,17 +79,29 @@ contract L1StandardBridge is StandardBridge, ISemver {
 
     /// @notice Constructs the L1StandardBridge contract.
     constructor() StandardBridge() {
-        initialize({ _messenger: CrossDomainMessenger(address(0)), _superchainConfig: SuperchainConfig(address(0)) });
+        initialize({
+            _messenger: CrossDomainMessenger(address(0)),
+            _superchainConfig: SuperchainConfig(address(0)),
+            _bobaToken: IERC20(address(0))
+        });
     }
 
     /// @notice Initializer.
     /// @param _messenger        Contract for the CrossDomainMessenger on this network.
     /// @param _superchainConfig Contract for the SuperchainConfig on this network.
-    function initialize(CrossDomainMessenger _messenger, SuperchainConfig _superchainConfig) public initializer {
+    function initialize(
+        CrossDomainMessenger _messenger,
+        SuperchainConfig _superchainConfig,
+        IERC20 _bobaToken
+    )
+        public
+        initializer
+    {
         superchainConfig = _superchainConfig;
         __StandardBridge_init({
             _messenger: _messenger,
-            _otherBridge: StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE))
+            _otherBridge: StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)),
+            _bobaToken: IERC20(_bobaToken)
         });
     }
 
diff --git a/packages/contracts-bedrock/src/L1/OptimismPortal.sol b/packages/contracts-bedrock/src/L1/OptimismPortal.sol
index 30e6bd471..ba86af443 100644
--- a/packages/contracts-bedrock/src/L1/OptimismPortal.sol
+++ b/packages/contracts-bedrock/src/L1/OptimismPortal.sol
@@ -14,6 +14,7 @@ import { AddressAliasHelper } from "src/vendor/AddressAliasHelper.sol";
 import { ResourceMetering } from "src/L1/ResourceMetering.sol";
 import { ISemver } from "src/universal/ISemver.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { Predeploys } from "src/libraries/Predeploys.sol";
 
 /// @custom:proxied
 /// @title OptimismPortal
@@ -406,11 +407,91 @@ contract OptimismPortal is Initializable, ResourceMetering, ISemver {
         // Compute the opaque data that will be emitted as part of the TransactionDeposited event.
         // We use opaque data so that we can update the TransactionDeposited event in the future
         // without breaking the current interface.
-        bytes memory opaqueData = abi.encodePacked(msg.value, _value, _gasLimit, _isCreation, _data);
+        bytes memory opaqueData = abi.encodePacked(uint256(0), _value, _gasLimit, _isCreation, _data);
 
         // Emit a TransactionDeposited event so that the rollup node can derive a deposit
         // transaction for this deposit.
         emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);
+
+        // If the user sent ETH with this transaction, we need to finalize the deposit ERC20 on L2.
+        if (msg.value != 0) {
+            bytes memory _message = abi.encodeWithSelector(
+                OptimismPortalHelper.finalizeBridgeERC20.selector,
+                Predeploys.L2_BNB,
+                address(0),
+                msg.sender,
+                _to,
+                msg.value,
+                new bytes(0)
+            );
+
+            _data = abi.encodeWithSelector(
+                OptimismPortalHelper.relayMessage.selector,
+                OptimismPortalHelper(systemConfig.l1CrossDomainMessenger()).messageNonce(),
+                systemConfig.l1StandardBridge(),
+                Predeploys.L2_STANDARD_BRIDGE,
+                uint256(0),
+                _gasLimit,
+                _message
+            );
+
+            opaqueData = abi.encodePacked(
+                uint256(0),
+                uint256(0),
+                OptimismPortalHelper(systemConfig.l1CrossDomainMessenger()).baseGas(_message, uint32(_gasLimit)),
+                false,
+                _data
+            );
+
+            emit TransactionDeposited(
+                AddressAliasHelper.applyL1ToL2Alias(systemConfig.l1CrossDomainMessenger()),
+                Predeploys.L2_CROSS_DOMAIN_MESSENGER,
+                DEPOSIT_VERSION,
+                opaqueData
+            );
+
+            return;
+        }
+
+        (address _sender, bytes memory _cdmMessage) = this.decodeCrossDomainMessenger(_data);
+
+        (address _tokenSender, address _tokenReceiver, uint256 _tokenAmount) =
+            this.decodeStandardBridge(_sender, _cdmMessage);
+
+        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.
+        // We use opaque data so that we can update the TransactionDeposited event in the future
+        // without breaking the current interface.
+        opaqueData = abi.encodePacked(_tokenAmount, uint256(0), _gasLimit, false, new bytes(0));
+
+        // Emit a TransactionDeposited event so that the rollup node can derive a deposit
+        // transaction for this deposit.
+        emit TransactionDeposited(_tokenSender, _tokenReceiver, DEPOSIT_VERSION, opaqueData);
+    }
+
+    function decodeCrossDomainMessenger(bytes calldata _data) external returns (address, bytes memory) {
+        require(msg.sender == systemConfig.l1CrossDomainMessenger(), "OptimismPortal: invalid msg.sender");
+        bytes4 selector;
+        assembly {
+            selector := calldataload(_data.offset)
+        }
+        require(selector == OptimismPortalHelper.relayMessage.selector, "OptimismPortal: invalid CDM selector");
+        (uint256 nonce, address sender, address target, uint256 value, uint256 gasLimit, bytes memory _message) =
+            abi.decode(_data[4:], (uint256, address, address, uint256, uint256, bytes));
+        require(target == Predeploys.L2_STANDARD_BRIDGE, "OptimismPortal: invalid target");
+        return (sender, _message);
+    }
+
+    function decodeStandardBridge(address sender, bytes calldata _data) external returns (address, address, uint256) {
+        require(msg.sender == systemConfig.l1CrossDomainMessenger(), "OptimismPortal: invalid msg.sender");
+        require(sender == systemConfig.l1StandardBridge(), "OptimismPortal: invalid sender");
+        bytes4 selector;
+        assembly {
+            selector := calldataload(_data.offset)
+        }
+        require(selector == OptimismPortalHelper.finalizeBridgeETH.selector, "OptimismPortal: invalid SB selector");
+        (address from, address to, uint256 amount, bytes memory extraData) =
+            abi.decode(_data[4:], (address, address, uint256, bytes));
+        return (from, to, amount);
     }
 
     /// @notice Determine if a given output is finalized.
@@ -430,3 +511,13 @@ contract OptimismPortal is Initializable, ResourceMetering, ISemver {
         return block.timestamp > _timestamp + l2Oracle.FINALIZATION_PERIOD_SECONDS();
     }
 }
+
+pragma solidity 0.8.15;
+
+interface OptimismPortalHelper {
+    function messageNonce() external view returns (uint256);
+    function baseGas(bytes calldata _message, uint32 _gasLimit) external view returns (uint64);
+    function relayMessage(uint256 _nonce, address _sender, address _target, uint256 _value, uint256 _minGasLimit, bytes calldata _message) external payable;
+    function finalizeBridgeETH(address _from, address _to, uint256 _amount, bytes calldata _extraData) external payable;
+    function finalizeBridgeERC20(address _localToken, address _remoteToken, address _from, address _to, uint256 _amount, bytes calldata _extraData) external;
+}
diff --git a/packages/contracts-bedrock/src/L2/L2StandardBridge.sol b/packages/contracts-bedrock/src/L2/L2StandardBridge.sol
index 69319560a..3adeb8244 100644
--- a/packages/contracts-bedrock/src/L2/L2StandardBridge.sol
+++ b/packages/contracts-bedrock/src/L2/L2StandardBridge.sol
@@ -7,6 +7,7 @@ import { ISemver } from "src/universal/ISemver.sol";
 import { OptimismMintableERC20 } from "src/universal/OptimismMintableERC20.sol";
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
 /// @custom:proxied
 /// @custom:predeploy 0x4200000000000000000000000000000000000010
@@ -65,7 +66,8 @@ contract L2StandardBridge is StandardBridge, ISemver {
     function initialize(StandardBridge _otherBridge) public initializer {
         __StandardBridge_init({
             _messenger: CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER),
-            _otherBridge: _otherBridge
+            _otherBridge: _otherBridge,
+            _bobaToken: IERC20(Predeploys.LEGACY_ERC20_ETH)
         });
     }
 
diff --git a/packages/contracts-bedrock/src/deployment/SystemDictator.sol b/packages/contracts-bedrock/src/deployment/SystemDictator.sol
index 52f0eeba1..8140280f8 100644
--- a/packages/contracts-bedrock/src/deployment/SystemDictator.sol
+++ b/packages/contracts-bedrock/src/deployment/SystemDictator.sol
@@ -2,6 +2,7 @@
 pragma solidity 0.8.15;
 
 import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import { L2OutputOracle } from "../L1/L2OutputOracle.sol";
 import { OptimismPortal } from "../L1/OptimismPortal.sol";
 import { L1CrossDomainMessenger } from "../L1/L1CrossDomainMessenger.sol";
@@ -35,6 +36,7 @@ contract SystemDictator is OwnableUpgradeable {
         ProxyAdmin proxyAdmin;
         address controller;
         address finalOwner;
+        address bobaToken;
     }
 
     /**
@@ -212,7 +214,7 @@ contract SystemDictator is OwnableUpgradeable {
         address zero = address(0);
         initialize(
             DeployConfig(
-                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero),
+                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero, zero),
                 ProxyAddressConfig(zero, zero, zero, zero, zero, zero, zero, zero, zero),
                 ImplementationAddressConfig(
                     L2OutputOracle(zero),
@@ -475,7 +477,8 @@ contract SystemDictator is OwnableUpgradeable {
         // Try to initialize the L1StandardBridge, only fail if it's already been initialized.
         try L1StandardBridge(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).initialize(
             L1CrossDomainMessenger(config.proxyAddressConfig.l1CrossDomainMessengerProxy),
-            SuperchainConfig(config.proxyAddressConfig.superchainConfigProxy)
+            SuperchainConfig(config.proxyAddressConfig.superchainConfigProxy),
+            IERC20(config.globalConfig.bobaToken)
         ) {
             // L1StandardBridge is the one annoying edge case difference between existing
             // networks and fresh networks because in existing networks it'll already be
diff --git a/packages/contracts-bedrock/src/libraries/Predeploys.sol b/packages/contracts-bedrock/src/libraries/Predeploys.sol
index d131542ec..165b63f39 100644
--- a/packages/contracts-bedrock/src/libraries/Predeploys.sol
+++ b/packages/contracts-bedrock/src/libraries/Predeploys.sol
@@ -110,4 +110,7 @@ library Predeploys {
 
     /// @notice Address of the EntryPoint predeploy.
     address internal constant EntryPoint = 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;
+
+    /// @notice Address of the L2 BNB Token address
+    address internal constant L2_BNB = 0x4200000000000000000000000000000000000023;
 }
diff --git a/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol b/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol
index b5048d5c7..1ec192733 100644
--- a/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol
+++ b/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol
@@ -6,6 +6,8 @@ import { SafeCall } from "src/libraries/SafeCall.sol";
 import { Hashing } from "src/libraries/Hashing.sol";
 import { Encoding } from "src/libraries/Encoding.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { Predeploys } from "src/libraries/Predeploys.sol";
+import { StandardBridge } from "src/universal/StandardBridge.sol";
 
 /// @custom:legacy
 /// @title CrossDomainMessengerLegacySpacer0
diff --git a/packages/contracts-bedrock/src/universal/StandardBridge.sol b/packages/contracts-bedrock/src/universal/StandardBridge.sol
index 2c2c8c241..17312d8a2 100644
--- a/packages/contracts-bedrock/src/universal/StandardBridge.sol
+++ b/packages/contracts-bedrock/src/universal/StandardBridge.sol
@@ -10,6 +10,7 @@ import { IOptimismMintableERC20, ILegacyMintableERC20 } from "src/universal/IOpt
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
 import { OptimismMintableERC20 } from "src/universal/OptimismMintableERC20.sol";
 import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
+import { Predeploys } from "src/libraries/Predeploys.sol";
 
 /// @custom:upgradeable
 /// @title StandardBridge
@@ -43,10 +44,12 @@ abstract contract StandardBridge is Initializable {
     /// @custom:network-specific
     StandardBridge public otherBridge;
 
+    IERC20 public bobaToken;
+
     /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.
     ///         A gap size of 45 was chosen here, so that the first slot used in a child contract
     ///         would be a multiple of 50.
-    uint256[45] private __gap;
+    uint256[44] private __gap;
 
     /// @notice Emitted when an ETH bridge is initiated to the other chain.
     /// @param from      Address of the sender.
@@ -116,13 +119,15 @@ abstract contract StandardBridge is Initializable {
     /// @param _otherBridge Contract for the other StandardBridge contract.
     function __StandardBridge_init(
         CrossDomainMessenger _messenger,
-        StandardBridge _otherBridge
+        StandardBridge _otherBridge,
+        IERC20 _bobaToken
     )
         internal
         onlyInitializing
     {
         messenger = _messenger;
         otherBridge = _otherBridge;
+        bobaToken = _bobaToken;
     }
 
     /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.
@@ -322,9 +327,30 @@ abstract contract StandardBridge is Initializable {
         // contracts may override this function in order to emit legacy events as well.
         _emitETHBridgeInitiated(_from, _to, _amount, _extraData);
 
+        // L1 to L2 bridge
+        // The other bridge is the L2 bridge, so we send a message to the L2 bridge to finalize the
+        // bnb transfer.
+        bytes memory _message = abi.encodeWithSelector(
+            this.finalizeBridgeERC20.selector, Predeploys.L2_BNB, address(0), _from, _to, _amount, _extraData
+        );
+        // L2 to L1 bridge
+        // The other bridge is the L1 bridge, so we send a message to the L1 bridge to finalize the
+        // boba transfer.
+        if (address(otherBridge) != Predeploys.L2_STANDARD_BRIDGE) {
+            _message = abi.encodeWithSelector(
+                this.finalizeBridgeERC20.selector,
+                bobaToken,
+                Predeploys.LEGACY_ERC20_ETH,
+                _from,
+                _to,
+                _amount,
+                _extraData
+            );
+        }
+
         messenger.sendMessage{ value: _amount }({
             _target: address(otherBridge),
-            _message: abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData),
+            _message: _message,
             _minGasLimit: _minGasLimit
         });
     }
@@ -365,22 +391,34 @@ abstract contract StandardBridge is Initializable {
         // contracts may override this function in order to emit legacy events as well.
         _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);
 
-        messenger.sendMessage({
-            _target: address(otherBridge),
-            _message: abi.encodeWithSelector(
-                this.finalizeBridgeERC20.selector,
-                // Because this call will be executed on the remote chain, we reverse the order of
-                // the remote and local token addresses relative to their order in the
-                // finalizeBridgeERC20 function.
-                _remoteToken,
-                _localToken,
-                _from,
-                _to,
-                _amount,
-                _extraData
-                ),
-            _minGasLimit: _minGasLimit
-        });
+        // Default message is to finalize the bridge on the other chain.
+        bytes memory _message = abi.encodeWithSelector(
+            this.finalizeBridgeERC20.selector,
+            // Because this call will be executed on the remote chain, we reverse the order of
+            // the remote and local token addresses relative to their order in the
+            // finalizeBridgeERC20 function.
+            _remoteToken,
+            _localToken,
+            _from,
+            _to,
+            _amount,
+            _extraData
+        );
+
+        // L1 to L2 bridge
+        // The other bridge is the L2 bridge, so we send a message to the L2 bridge to finalize the
+        // boba transfer.
+        if (address(otherBridge) == Predeploys.L2_STANDARD_BRIDGE && IERC20(_localToken) == bobaToken) {
+            _message = abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData);
+        }
+        // L2 to L1 bridge
+        // The other bridge is the L1 bridge, so we send a message to the L1 bridge to finalize the
+        // bnb transfer.
+        if (address(otherBridge) != Predeploys.L2_STANDARD_BRIDGE && _localToken == Predeploys.L2_BNB) {
+            _message = abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData);
+        }
+
+        messenger.sendMessage({ _target: address(otherBridge), _message: _message, _minGasLimit: _minGasLimit });
     }
 
     /// @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.
diff --git a/packages/contracts-bedrock/test/vendor/Initializable.t.sol b/packages/contracts-bedrock/test/vendor/Initializable.t.sol
index 56b264378..8d1a69ebc 100644
--- a/packages/contracts-bedrock/test/vendor/Initializable.t.sol
+++ b/packages/contracts-bedrock/test/vendor/Initializable.t.sol
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: MIT
 pragma solidity 0.8.15;
 
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import { Bridge_Initializer } from "test/setup/Bridge_Initializer.sol";
 import { Executables } from "scripts/Executables.sol";
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
@@ -228,7 +229,9 @@ contract Initializer_Test is Bridge_Initializer {
         contracts.push(
             InitializeableContract({
                 target: deploy.mustGetAddress("L1StandardBridge"),
-                initCalldata: abi.encodeCall(l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig)),
+                initCalldata: abi.encodeCall(
+                    l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig, IERC20(address(0)))
+                    ),
                 initializedSlotVal: deploy.loadInitializedSlot("L1StandardBridge")
             })
         );
@@ -236,7 +239,9 @@ contract Initializer_Test is Bridge_Initializer {
         contracts.push(
             InitializeableContract({
                 target: address(l1StandardBridge),
-                initCalldata: abi.encodeCall(l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig)),
+                initCalldata: abi.encodeCall(
+                    l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig, IERC20(address(0)))
+                    ),
                 initializedSlotVal: deploy.loadInitializedSlot("L1StandardBridgeProxy")
             })
         );
-- 
2.39.3 (Apple Git-146)

