From 1426b35f2b391b6c2cae8ccd3ef313555d4ee52e Mon Sep 17 00:00:00 2001
From: cby3149 <cby3149@gmail.com>
Date: Tue, 14 May 2024 14:40:07 -0400
Subject: [PATCH] BNB L2

---
 .../contracts-bedrock/scripts/Deploy.s.sol    |   6 +-
 .../contracts-bedrock/scripts/L2Genesis.s.sol |   5 +-
 .../src/L1/L1CrossDomainMessenger.sol         |  24 ++++
 .../src/L1/L1StandardBridge.sol               |  41 ++++---
 .../src/L1/OptimismPortal.sol                 | 107 ++++++++++++++++-
 .../src/L2/L2CrossDomainMessenger.sol         |  19 +++
 .../src/L2/L2StandardBridge.sol               |   8 +-
 .../src/L2/L2ToL1MessagePasser.sol            |  59 ++++++++++
 .../src/deployment/SystemDictator.sol         |   7 +-
 .../src/libraries/Predeploys.sol              |   3 +
 .../src/universal/CrossDomainMessenger.sol    | 104 +++++++++++++++++
 .../src/universal/StandardBridge.sol          | 109 ++++++++++++++----
 .../test/vendor/Initializable.t.sol           |  11 +-
 13 files changed, 454 insertions(+), 49 deletions(-)

diff --git a/packages/contracts-bedrock/scripts/Deploy.s.sol b/packages/contracts-bedrock/scripts/Deploy.s.sol
index d0acd4940..170a65256 100644
--- a/packages/contracts-bedrock/scripts/Deploy.s.sol
+++ b/packages/contracts-bedrock/scripts/Deploy.s.sol
@@ -878,7 +878,11 @@ contract Deploy is Deployer {
             _implementation: l1StandardBridge,
             _innerCallData: abi.encodeCall(
                 L1StandardBridge.initialize,
-                (L1CrossDomainMessenger(l1CrossDomainMessengerProxy), SuperchainConfig(superchainConfigProxy))
+                (
+                    L1CrossDomainMessenger(l1CrossDomainMessengerProxy),
+                    SuperchainConfig(superchainConfigProxy),
+                    BOBA(address(0))
+                )
                 )
         });
 
diff --git a/packages/contracts-bedrock/scripts/L2Genesis.s.sol b/packages/contracts-bedrock/scripts/L2Genesis.s.sol
index 5f5f8a198..64eb39d96 100644
--- a/packages/contracts-bedrock/scripts/L2Genesis.s.sol
+++ b/packages/contracts-bedrock/scripts/L2Genesis.s.sol
@@ -17,6 +17,7 @@ import { OptimismMintableERC20Factory } from "src/universal/OptimismMintableERC2
 import { L1Block } from "src/L2/L1Block.sol";
 import { GovernanceToken } from "src/governance/GovernanceToken.sol";
 import { EIP1967Helper } from "test/mocks/EIP1967Helper.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
 interface IInitializable {
     function initialize(address _addr) external;
@@ -216,10 +217,10 @@ contract L2Genesis is Script, Artifacts {
     function _setL2StandardBridge() internal {
         address impl = _setImplementationCode(Predeploys.L2_STANDARD_BRIDGE, "L2StandardBridge");
 
-        L2StandardBridge(payable(impl)).initialize(L1StandardBridge(payable(address(0))));
+        L2StandardBridge(payable(impl)).initialize(L1StandardBridge(payable(address(0))), IERC20(address(0)));
 
         L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).initialize(
-            L1StandardBridge(mustGetAddress("L1StandardBridgeProxy"))
+            L1StandardBridge(mustGetAddress("L1StandardBridgeProxy")), IERC20(address(0))
         );
 
         _checkL2StandardBridge(impl);
diff --git a/packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol b/packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol
index deccbed23..b4e130bd4 100644
--- a/packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol
+++ b/packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol
@@ -63,6 +63,30 @@ contract L1CrossDomainMessenger is CrossDomainMessenger, ISemver {
         });
     }
 
+    /// @inheritdoc CrossDomainMessenger
+    function _depositBoba(
+        address _from,
+        address _to,
+        uint64 _gasLimit,
+        uint256 _value,
+        bytes memory _data
+    )
+        internal
+        override
+    {
+        portal.depositBoba({ _from: _from, _to: _to, _value: _value, _gasLimit: _gasLimit, _data: _data });
+    }
+
+    /// @inheritdoc CrossDomainMessenger
+    function _withdrawBoba(address, uint64, uint256, bytes memory) internal pure override {
+        revert("L1CrossDomainMessenger: Boba not supported");
+    }
+
+    /// @inheritdoc CrossDomainMessenger
+    function _withdrawBnb(address, uint64, uint256, bytes memory) internal override {
+        revert("L1CrossDomainMessenger: BNB not supported");
+    }
+
     /// @inheritdoc CrossDomainMessenger
     function _isOtherMessenger() internal view override returns (bool) {
         return msg.sender == address(portal) && portal.l2Sender() == address(otherMessenger);
diff --git a/packages/contracts-bedrock/src/L1/L1StandardBridge.sol b/packages/contracts-bedrock/src/L1/L1StandardBridge.sol
index 6958dc2e7..5a7b27908 100644
--- a/packages/contracts-bedrock/src/L1/L1StandardBridge.sol
+++ b/packages/contracts-bedrock/src/L1/L1StandardBridge.sol
@@ -7,6 +7,7 @@ import { ISemver } from "src/universal/ISemver.sol";
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
 import { SuperchainConfig } from "src/L1/SuperchainConfig.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
 /// @custom:proxied
 /// @title L1StandardBridge
@@ -78,17 +79,29 @@ contract L1StandardBridge is StandardBridge, ISemver {
 
     /// @notice Constructs the L1StandardBridge contract.
     constructor() StandardBridge() {
-        initialize({ _messenger: CrossDomainMessenger(address(0)), _superchainConfig: SuperchainConfig(address(0)) });
+        initialize({
+            _messenger: CrossDomainMessenger(address(0)),
+            _superchainConfig: SuperchainConfig(address(0)),
+            _bobaToken: IERC20(address(0))
+        });
     }
 
     /// @notice Initializer.
     /// @param _messenger        Contract for the CrossDomainMessenger on this network.
     /// @param _superchainConfig Contract for the SuperchainConfig on this network.
-    function initialize(CrossDomainMessenger _messenger, SuperchainConfig _superchainConfig) public initializer {
+    function initialize(
+        CrossDomainMessenger _messenger,
+        SuperchainConfig _superchainConfig,
+        IERC20 _bobaToken
+    )
+        public
+        initializer
+    {
         superchainConfig = _superchainConfig;
         __StandardBridge_init({
             _messenger: _messenger,
-            _otherBridge: StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE))
+            _otherBridge: StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)),
+            _bobaToken: IERC20(_bobaToken)
         });
     }
 
@@ -106,17 +119,15 @@ contract L1StandardBridge is StandardBridge, ISemver {
 
     /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.
     receive() external payable override onlyEOA {
-        _initiateETHDeposit(msg.sender, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(""));
+        // _initiateETHDeposit(msg.sender, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(""));
+        revert("L1StandardBridge: receive not supported");
     }
 
     /// @custom:legacy
     /// @notice Deposits some amount of ETH into the sender's account on L2.
-    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.
-    /// @param _extraData   Optional data to forward to L2.
-    ///                     Data supplied here will not be used to execute any code on L2 and is
-    ///                     only emitted as extra data for the convenience of off-chain tooling.
-    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {
-        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);
+    function depositETH(uint32, bytes calldata) external payable onlyEOA {
+        // _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);
+        revert("L1StandardBridge: depositETH not supported");
     }
 
     /// @custom:legacy
@@ -125,13 +136,9 @@ contract L1StandardBridge is StandardBridge, ISemver {
     ///         be locked in the L2StandardBridge. ETH may be recoverable if the call can be
     ///         successfully replayed by increasing the amount of gas supplied to the call. If the
     ///         call will fail for any amount of gas, then the ETH will be locked permanently.
-    /// @param _to          Address of the recipient on L2.
-    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.
-    /// @param _extraData   Optional data to forward to L2.
-    ///                     Data supplied here will not be used to execute any code on L2 and is
-    ///                     only emitted as extra data for the convenience of off-chain tooling.
-    function depositETHTo(address _to, uint32 _minGasLimit, bytes calldata _extraData) external payable {
-        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);
+    function depositETHTo(address, uint32, bytes calldata) external payable {
+        // _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);
+        revert("L1StandardBridge: depositETHTo not supported");
     }
 
     /// @custom:legacy
diff --git a/packages/contracts-bedrock/src/L1/OptimismPortal.sol b/packages/contracts-bedrock/src/L1/OptimismPortal.sol
index 30e6bd471..60c8d1b13 100644
--- a/packages/contracts-bedrock/src/L1/OptimismPortal.sol
+++ b/packages/contracts-bedrock/src/L1/OptimismPortal.sol
@@ -14,6 +14,7 @@ import { AddressAliasHelper } from "src/vendor/AddressAliasHelper.sol";
 import { ResourceMetering } from "src/L1/ResourceMetering.sol";
 import { ISemver } from "src/universal/ISemver.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { Predeploys } from "src/libraries/Predeploys.sol";
 
 /// @custom:proxied
 /// @title OptimismPortal
@@ -406,7 +407,77 @@ contract OptimismPortal is Initializable, ResourceMetering, ISemver {
         // Compute the opaque data that will be emitted as part of the TransactionDeposited event.
         // We use opaque data so that we can update the TransactionDeposited event in the future
         // without breaking the current interface.
-        bytes memory opaqueData = abi.encodePacked(msg.value, _value, _gasLimit, _isCreation, _data);
+        bytes memory opaqueData = abi.encodePacked(uint256(0), _value, _gasLimit, _isCreation, _data);
+
+        // Emit a TransactionDeposited event so that the rollup node can derive a deposit
+        // transaction for this deposit.
+        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);
+
+        // If the user sent ETH with this transaction, we need to finalize the deposit ERC20 on L2.
+        if (msg.value != 0) {
+            require(msg.sender == tx.origin, "OptimismPortal: cannot deposit ETH from a contract");
+            bytes memory _message = abi.encodeWithSelector(
+                OptimismPortalHelper.finalizeBridgeERC20.selector,
+                Predeploys.L2_BNB,
+                address(0),
+                msg.sender,
+                _to,
+                msg.value,
+                new bytes(0)
+            );
+
+            _data = abi.encodeWithSelector(
+                OptimismPortalHelper.relayMessage.selector,
+                OptimismPortalHelper(systemConfig.l1CrossDomainMessenger()).messageNonce(),
+                systemConfig.l1StandardBridge(),
+                Predeploys.L2_STANDARD_BRIDGE,
+                uint256(0),
+                _gasLimit,
+                _message
+            );
+
+            opaqueData = abi.encodePacked(
+                uint256(0),
+                uint256(0),
+                OptimismPortalHelper(systemConfig.l1CrossDomainMessenger()).baseGas(_message, uint32(_gasLimit)),
+                false,
+                _data
+            );
+
+            emit TransactionDeposited(
+                AddressAliasHelper.applyL1ToL2Alias(systemConfig.l1CrossDomainMessenger()),
+                Predeploys.L2_CROSS_DOMAIN_MESSENGER,
+                DEPOSIT_VERSION,
+                opaqueData
+            );
+        }
+    }
+
+    function depositBoba(
+        address _from,
+        address _to,
+        uint256 _value,
+        uint64 _gasLimit,
+        bytes memory _data
+    )
+        public
+        metered(_gasLimit)
+    {
+        require(_from == systemConfig.l1StandardBridge(), "OptimismPortal: invalid sender");
+        require(msg.sender == systemConfig.l1CrossDomainMessenger(), "OptimismPortal: invalid msg.sender");
+
+        // Prevent depositing transactions that have too small of a gas limit. Users should pay
+        // more for more resource usage.
+        require(_gasLimit >= minimumGasLimit(uint64(_data.length)), "OptimismPortal: gas limit too small");
+
+        // Prevent the creation of deposit transactions that have too much calldata. This gives an
+        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure
+        // that the transaction can fit into the p2p network policy of 128kb even though deposit
+        // transactions are not gossipped over the p2p network.
+        require(_data.length <= 120_000, "OptimismPortal: data too large");
+
+        address from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);
+        bytes memory opaqueData = abi.encodePacked(_value, _value, _gasLimit, false, _data);
 
         // Emit a TransactionDeposited event so that the rollup node can derive a deposit
         // transaction for this deposit.
@@ -430,3 +501,37 @@ contract OptimismPortal is Initializable, ResourceMetering, ISemver {
         return block.timestamp > _timestamp + l2Oracle.FINALIZATION_PERIOD_SECONDS();
     }
 }
+
+pragma solidity 0.8.15;
+
+interface OptimismPortalHelper {
+    function messageNonce() external view returns (uint256);
+    function baseGas(bytes calldata _message, uint32 _gasLimit) external view returns (uint64);
+    function relayMessage(
+        uint256 _nonce,
+        address _sender,
+        address _target,
+        uint256 _value,
+        uint256 _minGasLimit,
+        bytes calldata _message
+    )
+        external
+        payable;
+    function finalizeBridgeETH(
+        address _from,
+        address _to,
+        uint256 _amount,
+        bytes calldata _extraData
+    )
+        external
+        payable;
+    function finalizeBridgeERC20(
+        address _localToken,
+        address _remoteToken,
+        address _from,
+        address _to,
+        uint256 _amount,
+        bytes calldata _extraData
+    )
+        external;
+}
diff --git a/packages/contracts-bedrock/src/L2/L2CrossDomainMessenger.sol b/packages/contracts-bedrock/src/L2/L2CrossDomainMessenger.sol
index ad0e117d3..55c23f688 100644
--- a/packages/contracts-bedrock/src/L2/L2CrossDomainMessenger.sol
+++ b/packages/contracts-bedrock/src/L2/L2CrossDomainMessenger.sol
@@ -44,6 +44,25 @@ contract L2CrossDomainMessenger is CrossDomainMessenger, ISemver {
         );
     }
 
+    /// @inheritdoc CrossDomainMessenger
+    function _depositBoba(address, address, uint64, uint256, bytes memory) internal pure override {
+        revert("L2CrossDomainMessenger: Boba not supported");
+    }
+
+    /// @inheritdoc CrossDomainMessenger
+    function _withdrawBoba(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal override {
+        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateBobaWithdrawal{ value: _value }(
+            _to, _gasLimit, _data
+        );
+    }
+
+    /// @inheritdoc CrossDomainMessenger
+    function _withdrawBnb(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal override {
+        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateBnbWithdrawal(
+            _to, _value, _gasLimit, _data
+        );
+    }
+
     /// @inheritdoc CrossDomainMessenger
     function _isOtherMessenger() internal view override returns (bool) {
         return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == address(otherMessenger);
diff --git a/packages/contracts-bedrock/src/L2/L2StandardBridge.sol b/packages/contracts-bedrock/src/L2/L2StandardBridge.sol
index 69319560a..1b29ea00b 100644
--- a/packages/contracts-bedrock/src/L2/L2StandardBridge.sol
+++ b/packages/contracts-bedrock/src/L2/L2StandardBridge.sol
@@ -7,6 +7,7 @@ import { ISemver } from "src/universal/ISemver.sol";
 import { OptimismMintableERC20 } from "src/universal/OptimismMintableERC20.sol";
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
 /// @custom:proxied
 /// @custom:predeploy 0x4200000000000000000000000000000000000010
@@ -57,15 +58,16 @@ contract L2StandardBridge is StandardBridge, ISemver {
 
     /// @notice Constructs the L2StandardBridge contract.
     constructor() StandardBridge() {
-        initialize({ _otherBridge: StandardBridge(payable(address(0))) });
+        initialize({ _otherBridge: StandardBridge(payable(address(0))), _otherBobaToken: IERC20(address(0)) });
     }
 
     /// @notice Initializer.
     /// @param _otherBridge Contract for the corresponding bridge on the other chain.
-    function initialize(StandardBridge _otherBridge) public initializer {
+    function initialize(StandardBridge _otherBridge, IERC20 _otherBobaToken) public initializer {
         __StandardBridge_init({
             _messenger: CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER),
-            _otherBridge: _otherBridge
+            _otherBridge: _otherBridge,
+            _bobaToken: _otherBobaToken
         });
     }
 
diff --git a/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol b/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol
index 8c764e999..f44101f9f 100644
--- a/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol
+++ b/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol
@@ -91,6 +91,65 @@ contract L2ToL1MessagePasser is ISemver {
         }
     }
 
+    /// @notice Send a message from L2 to L1 to withdraw BOBA.
+    /// @param _target   Address to call on L1 execution.
+    /// @param _gasLimit Minimum gas limit for executing the message on L1.
+    /// @param _data     Data to forward to L1 target.
+    function initiateBobaWithdrawal(address _target, uint256 _gasLimit, bytes memory _data) public payable {
+        bytes32 withdrawalHash = Hashing.hashWithdrawal(
+            Types.WithdrawalTransaction({
+                nonce: messageNonce(),
+                sender: msg.sender,
+                target: _target,
+                value: uint256(0),
+                gasLimit: _gasLimit,
+                data: _data
+            })
+        );
+
+        sentMessages[withdrawalHash] = true;
+
+        emit MessagePassed(messageNonce(), msg.sender, _target, uint256(0), _gasLimit, _data, withdrawalHash);
+
+        unchecked {
+            ++msgNonce;
+        }
+    }
+
+    /// @notice Send a message from L2 to L1 to withdraw BNB.
+    /// @param _target   Address to call on L1 execution.
+    /// @param _value    Amount of BNB to withdraw.
+    /// @param _gasLimit Minimum gas limit for executing the message on L1.
+    /// @param _data     Data to forward to L1 target.
+    function initiateBnbWithdrawal(
+        address _target,
+        uint256 _value,
+        uint256 _gasLimit,
+        bytes memory _data
+    )
+        public
+        payable
+    {
+        bytes32 withdrawalHash = Hashing.hashWithdrawal(
+            Types.WithdrawalTransaction({
+                nonce: messageNonce(),
+                sender: msg.sender,
+                target: _target,
+                value: _value,
+                gasLimit: _gasLimit,
+                data: _data
+            })
+        );
+
+        sentMessages[withdrawalHash] = true;
+
+        emit MessagePassed(messageNonce(), msg.sender, _target, _value, _gasLimit, _data, withdrawalHash);
+
+        unchecked {
+            ++msgNonce;
+        }
+    }
+
     /// @notice Retrieves the next message nonce. Message version will be added to the upper two
     ///         bytes of the message nonce. Message version allows us to treat messages as having
     ///         different structures.
diff --git a/packages/contracts-bedrock/src/deployment/SystemDictator.sol b/packages/contracts-bedrock/src/deployment/SystemDictator.sol
index 52f0eeba1..8140280f8 100644
--- a/packages/contracts-bedrock/src/deployment/SystemDictator.sol
+++ b/packages/contracts-bedrock/src/deployment/SystemDictator.sol
@@ -2,6 +2,7 @@
 pragma solidity 0.8.15;
 
 import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import { L2OutputOracle } from "../L1/L2OutputOracle.sol";
 import { OptimismPortal } from "../L1/OptimismPortal.sol";
 import { L1CrossDomainMessenger } from "../L1/L1CrossDomainMessenger.sol";
@@ -35,6 +36,7 @@ contract SystemDictator is OwnableUpgradeable {
         ProxyAdmin proxyAdmin;
         address controller;
         address finalOwner;
+        address bobaToken;
     }
 
     /**
@@ -212,7 +214,7 @@ contract SystemDictator is OwnableUpgradeable {
         address zero = address(0);
         initialize(
             DeployConfig(
-                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero),
+                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero, zero),
                 ProxyAddressConfig(zero, zero, zero, zero, zero, zero, zero, zero, zero),
                 ImplementationAddressConfig(
                     L2OutputOracle(zero),
@@ -475,7 +477,8 @@ contract SystemDictator is OwnableUpgradeable {
         // Try to initialize the L1StandardBridge, only fail if it's already been initialized.
         try L1StandardBridge(payable(config.proxyAddressConfig.l1StandardBridgeProxy)).initialize(
             L1CrossDomainMessenger(config.proxyAddressConfig.l1CrossDomainMessengerProxy),
-            SuperchainConfig(config.proxyAddressConfig.superchainConfigProxy)
+            SuperchainConfig(config.proxyAddressConfig.superchainConfigProxy),
+            IERC20(config.globalConfig.bobaToken)
         ) {
             // L1StandardBridge is the one annoying edge case difference between existing
             // networks and fresh networks because in existing networks it'll already be
diff --git a/packages/contracts-bedrock/src/libraries/Predeploys.sol b/packages/contracts-bedrock/src/libraries/Predeploys.sol
index d131542ec..165b63f39 100644
--- a/packages/contracts-bedrock/src/libraries/Predeploys.sol
+++ b/packages/contracts-bedrock/src/libraries/Predeploys.sol
@@ -110,4 +110,7 @@ library Predeploys {
 
     /// @notice Address of the EntryPoint predeploy.
     address internal constant EntryPoint = 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;
+
+    /// @notice Address of the L2 BNB Token address
+    address internal constant L2_BNB = 0x4200000000000000000000000000000000000023;
 }
diff --git a/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol b/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol
index b5048d5c7..e3f204222 100644
--- a/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol
+++ b/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol
@@ -6,6 +6,8 @@ import { SafeCall } from "src/libraries/SafeCall.sol";
 import { Hashing } from "src/libraries/Hashing.sol";
 import { Encoding } from "src/libraries/Encoding.sol";
 import { Constants } from "src/libraries/Constants.sol";
+import { Predeploys } from "src/libraries/Predeploys.sol";
+import { StandardBridge } from "src/universal/StandardBridge.sol";
 
 /// @custom:legacy
 /// @title CrossDomainMessengerLegacySpacer0
@@ -195,6 +197,78 @@ abstract contract CrossDomainMessenger is
         }
     }
 
+    /// @notice depositBoba sends a message to the other chain with a value of BOBA as ETH.
+    /// @param _target     Target contract or wallet address.
+    /// @param _amount     Amount of BOBA to send with the message.
+    /// @param _message    Message to trigger the target address with.
+    /// @param _minGasLimit Minimum gas limit that the message can be executed with.
+    function depositBoba(address _target, uint256 _amount, bytes calldata _message, uint32 _minGasLimit) external {
+        _depositBoba({
+            _from: msg.sender,
+            _to: address(otherMessenger),
+            _gasLimit: baseGas(_message, _minGasLimit),
+            _value: _amount,
+            _data: abi.encodeWithSelector(
+                this.relayMessage.selector, messageNonce(), msg.sender, _target, _amount, _minGasLimit, _message
+                )
+        });
+
+        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);
+        emit SentMessageExtension1(msg.sender, _amount);
+
+        unchecked {
+            ++msgNonce;
+        }
+    }
+
+    /// @notice withdrawBoba sends a message to the other chain to withdraw BOBA.
+    /// @param _target     Target contract or wallet address.
+    /// @param _message    Message to trigger the target address with.
+    /// @param _minGasLimit Minimum gas limit that the message can be executed with.
+    function withdrawBoba(address _target, bytes calldata _message, uint32 _minGasLimit) external payable {
+        // Triggers a message to the other messenger. Note that the amount of gas provided to the
+        // message is the amount of gas requested by the user PLUS the base gas value. We want to
+        // guarantee the property that the call to the target contract will always have at least
+        // the minimum gas limit specified by the user.
+        _withdrawBoba({
+            _to: address(otherMessenger),
+            _gasLimit: baseGas(_message, _minGasLimit),
+            _value: msg.value,
+            _data: abi.encodeWithSelector(
+                this.relayMessage.selector, messageNonce(), msg.sender, _target, 0, _minGasLimit, _message
+                )
+        });
+
+        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);
+        emit SentMessageExtension1(msg.sender, msg.value);
+
+        unchecked {
+            ++msgNonce;
+        }
+    }
+
+    function withdrawBnb(address _target, uint256 _value, bytes calldata _message, uint32 _minGasLimit) external {
+        // Triggers a message to the other messenger. Note that the amount of gas provided to the
+        // message is the amount of gas requested by the user PLUS the base gas value. We want to
+        // guarantee the property that the call to the target contract will always have at least
+        // the minimum gas limit specified by the user.
+        _withdrawBnb({
+            _to: address(otherMessenger),
+            _gasLimit: baseGas(_message, _minGasLimit),
+            _value: _value,
+            _data: abi.encodeWithSelector(
+                this.relayMessage.selector, messageNonce(), msg.sender, _target, _value, _minGasLimit, _message
+                )
+        });
+
+        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);
+        emit SentMessageExtension1(msg.sender, 0);
+
+        unchecked {
+            ++msgNonce;
+        }
+    }
+
     /// @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only
     ///         be executed via cross-chain call from the other messenger OR if the message was
     ///         already received once and is currently being replayed.
@@ -380,6 +454,36 @@ abstract contract CrossDomainMessenger is
     /// @param _data     Message data.
     function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal virtual;
 
+    /// @notice Sends a low-level message to the other messenger with a value of Boba as ETH.
+    /// @param _from     Address of the sender of the message.
+    /// @param _to       Recipient of the message on the other chain.
+    /// @param _gasLimit Minimum gas limit the message can be executed with.
+    /// @param _value    Amount of BOBA to send with the message.
+    /// @param _data     Message data.
+    function _depositBoba(
+        address _from,
+        address _to,
+        uint64 _gasLimit,
+        uint256 _value,
+        bytes memory _data
+    )
+        internal
+        virtual;
+
+    /// @notice Sends a low-level message to the other messenger to withdraw Boba.
+    /// @param _to       Recipient of the message on the other chain.
+    /// @param _gasLimit Minimum gas limit the message can be executed with.
+    /// @param _value    Amount of BOBA to send with the message.
+    /// @param _data     Message data.
+    function _withdrawBoba(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal virtual;
+
+    /// @notice Sends a low-level message to the other messenger to withdraw BNB.
+    /// @param _to       Recipient of the message on the other chain.
+    /// @param _gasLimit Minimum gas limit the message can be executed with.
+    /// @param _value    Amount of BNB to send with the message.
+    /// @param _data     Message data.
+    function _withdrawBnb(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal virtual;
+
     /// @notice Checks whether the message is coming from the other messenger. Implemented by child
     ///         contracts because the logic for this depends on the network where the messenger is
     ///         being deployed.
diff --git a/packages/contracts-bedrock/src/universal/StandardBridge.sol b/packages/contracts-bedrock/src/universal/StandardBridge.sol
index 2c2c8c241..fd3696905 100644
--- a/packages/contracts-bedrock/src/universal/StandardBridge.sol
+++ b/packages/contracts-bedrock/src/universal/StandardBridge.sol
@@ -10,6 +10,7 @@ import { IOptimismMintableERC20, ILegacyMintableERC20 } from "src/universal/IOpt
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
 import { OptimismMintableERC20 } from "src/universal/OptimismMintableERC20.sol";
 import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
+import { Predeploys } from "src/libraries/Predeploys.sol";
 
 /// @custom:upgradeable
 /// @title StandardBridge
@@ -43,10 +44,12 @@ abstract contract StandardBridge is Initializable {
     /// @custom:network-specific
     StandardBridge public otherBridge;
 
+    IERC20 public bobaToken;
+
     /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.
     ///         A gap size of 45 was chosen here, so that the first slot used in a child contract
     ///         would be a multiple of 50.
-    uint256[45] private __gap;
+    uint256[44] private __gap;
 
     /// @notice Emitted when an ETH bridge is initiated to the other chain.
     /// @param from      Address of the sender.
@@ -116,13 +119,15 @@ abstract contract StandardBridge is Initializable {
     /// @param _otherBridge Contract for the other StandardBridge contract.
     function __StandardBridge_init(
         CrossDomainMessenger _messenger,
-        StandardBridge _otherBridge
+        StandardBridge _otherBridge,
+        IERC20 _bobaToken
     )
         internal
         onlyInitializing
     {
         messenger = _messenger;
         otherBridge = _otherBridge;
+        bobaToken = _bobaToken;
     }
 
     /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.
@@ -322,9 +327,36 @@ abstract contract StandardBridge is Initializable {
         // contracts may override this function in order to emit legacy events as well.
         _emitETHBridgeInitiated(_from, _to, _amount, _extraData);
 
+        // L1 to L2 bridge
+        // The other bridge is the L2 bridge, so we send a message to the L2 bridge to finalize the
+        // bnb transfer.
+        bytes memory _message = abi.encodeWithSelector(
+            this.finalizeBridgeERC20.selector, Predeploys.L2_BNB, address(0), _from, _to, _amount, _extraData
+        );
+        // L2 to L1 bridge
+        // The other bridge is the L1 bridge, so we send a message to the L1 bridge to finalize the
+        // boba transfer.
+        if (address(otherBridge) != Predeploys.L2_STANDARD_BRIDGE) {
+            _message = abi.encodeWithSelector(
+                this.finalizeBridgeERC20.selector,
+                bobaToken,
+                Predeploys.LEGACY_ERC20_ETH,
+                _from,
+                _to,
+                _amount,
+                _extraData
+            );
+            messenger.withdrawBoba{ value: _amount }({
+                _target: address(otherBridge),
+                _message: _message,
+                _minGasLimit: _minGasLimit
+            });
+            return;
+        }
+
         messenger.sendMessage{ value: _amount }({
             _target: address(otherBridge),
-            _message: abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData),
+            _message: _message,
             _minGasLimit: _minGasLimit
         });
     }
@@ -358,29 +390,66 @@ abstract contract StandardBridge is Initializable {
             OptimismMintableERC20(_localToken).burn(_from, _amount);
         } else {
             IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);
-            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;
+
+            // we need to handle the case where the other bridge is the L2 bridge and the token is boba
+            if (address(otherBridge) == Predeploys.L2_STANDARD_BRIDGE && IERC20(_localToken) == bobaToken) {
+                require(
+                    _remoteToken == Predeploys.LEGACY_ERC20_ETH || _remoteToken == address(0),
+                    "StandardBridge: invalid remote token for boba"
+                );
+                deposits[_localToken][Predeploys.LEGACY_ERC20_ETH] =
+                    deposits[_localToken][Predeploys.LEGACY_ERC20_ETH] + _amount;
+            } else {
+                deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;
+            }
         }
 
         // Emit the correct events. By default this will be ERC20BridgeInitiated, but child
         // contracts may override this function in order to emit legacy events as well.
         _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);
 
-        messenger.sendMessage({
-            _target: address(otherBridge),
-            _message: abi.encodeWithSelector(
-                this.finalizeBridgeERC20.selector,
-                // Because this call will be executed on the remote chain, we reverse the order of
-                // the remote and local token addresses relative to their order in the
-                // finalizeBridgeERC20 function.
-                _remoteToken,
-                _localToken,
-                _from,
-                _to,
-                _amount,
-                _extraData
-                ),
-            _minGasLimit: _minGasLimit
-        });
+        // Default message is to finalize the bridge on the other chain.
+        bytes memory _message = abi.encodeWithSelector(
+            this.finalizeBridgeERC20.selector,
+            // Because this call will be executed on the remote chain, we reverse the order of
+            // the remote and local token addresses relative to their order in the
+            // finalizeBridgeERC20 function.
+            _remoteToken,
+            _localToken,
+            _from,
+            _to,
+            _amount,
+            _extraData
+        );
+
+        // L1 to L2 bridge
+        // The other bridge is the L2 bridge, so we send a message to the L2 bridge to finalize the
+        // boba transfer.
+        if (address(otherBridge) == Predeploys.L2_STANDARD_BRIDGE && IERC20(_localToken) == bobaToken) {
+            _message = abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData);
+            messenger.depositBoba({
+                _target: address(otherBridge),
+                _amount: _amount,
+                _message: _message,
+                _minGasLimit: _minGasLimit
+            });
+            return;
+        }
+        // L2 to L1 bridge
+        // The other bridge is the L1 bridge, so we send a message to the L1 bridge to finalize the
+        // bnb transfer.
+        if (address(otherBridge) != Predeploys.L2_STANDARD_BRIDGE && _localToken == Predeploys.L2_BNB) {
+            _message = abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData);
+            messenger.withdrawBnb({
+                _target: address(otherBridge),
+                _value: _amount,
+                _message: _message,
+                _minGasLimit: _minGasLimit
+            });
+            return;
+        }
+
+        messenger.sendMessage({ _target: address(otherBridge), _message: _message, _minGasLimit: _minGasLimit });
     }
 
     /// @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.
diff --git a/packages/contracts-bedrock/test/vendor/Initializable.t.sol b/packages/contracts-bedrock/test/vendor/Initializable.t.sol
index 56b264378..1f8a14d4d 100644
--- a/packages/contracts-bedrock/test/vendor/Initializable.t.sol
+++ b/packages/contracts-bedrock/test/vendor/Initializable.t.sol
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: MIT
 pragma solidity 0.8.15;
 
+import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import { Bridge_Initializer } from "test/setup/Bridge_Initializer.sol";
 import { Executables } from "scripts/Executables.sol";
 import { CrossDomainMessenger } from "src/universal/CrossDomainMessenger.sol";
@@ -228,7 +229,9 @@ contract Initializer_Test is Bridge_Initializer {
         contracts.push(
             InitializeableContract({
                 target: deploy.mustGetAddress("L1StandardBridge"),
-                initCalldata: abi.encodeCall(l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig)),
+                initCalldata: abi.encodeCall(
+                    l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig, IERC20(address(0)))
+                    ),
                 initializedSlotVal: deploy.loadInitializedSlot("L1StandardBridge")
             })
         );
@@ -236,7 +239,9 @@ contract Initializer_Test is Bridge_Initializer {
         contracts.push(
             InitializeableContract({
                 target: address(l1StandardBridge),
-                initCalldata: abi.encodeCall(l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig)),
+                initCalldata: abi.encodeCall(
+                    l1StandardBridge.initialize, (l1CrossDomainMessenger, superchainConfig, IERC20(address(0)))
+                    ),
                 initializedSlotVal: deploy.loadInitializedSlot("L1StandardBridgeProxy")
             })
         );
@@ -244,7 +249,7 @@ contract Initializer_Test is Bridge_Initializer {
         contracts.push(
             InitializeableContract({
                 target: address(l2StandardBridge),
-                initCalldata: abi.encodeCall(l2StandardBridge.initialize, (l1StandardBridge)),
+                initCalldata: abi.encodeCall(l2StandardBridge.initialize, (l1StandardBridge, IERC20(address(0)))),
                 initializedSlotVal: deploy.loadInitializedSlot("L2StandardBridge")
             })
         );
-- 
2.39.3 (Apple Git-146)

